"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  VitePress: () => VitePress,
  createField: () => createField,
  createFile: () => createFile,
  createFileCollection: () => createFileCollection,
  createFolderCollection: () => createFolderCollection,
  createOverwriteableField: () => createOverwriteableField,
  createSharedCollectionOptions: () => createSharedCollectionOptions,
  default: () => VitePluginDecapCMS,
  fieldToSnakeCase: () => fieldToSnakeCase,
  getGitData: () => getGitData
});
module.exports = __toCommonJS(src_exports);

// src/update.ts
var import_promises = require("fs/promises");
var import_node_path = require("path");
var import_yaml = require("yaml");

// src/utils/git.ts
var import_node_child_process = require("child_process");
function getGitData() {
  const executeGit = (command) => {
    try {
      return (0, import_node_child_process.execSync)(command).toString("utf8").replace(/[\n\r\s]+$/, "");
    } catch (e) {
    }
  };
  return {
    getBranch() {
      return executeGit("git rev-parse --abbrev-ref HEAD");
    },
    getCommitSha() {
      return executeGit("git rev-parse HEAD");
    }
  };
}

// src/utils/object.ts
var objToSnakeCase = (obj) => {
  const ignoredKeys = ["i18n"];
  const camelToSnakeCase = (str) => str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  return Object.fromEntries(
    Object.entries(obj).map(([k, v]) => [ignoredKeys.includes(k) ? k : camelToSnakeCase(k), v])
  );
};
var keyof = (obj) => Object.keys(obj);
function filterUndefined(item) {
  return item != void 0;
}
function omit(obj, keys) {
  if (!obj) return {};
  const validEntries = Object.entries(obj).filter(([key]) => !keys.includes(key));
  return Object.fromEntries(validEntries);
}
function pick(obj, keys) {
  if (!obj) return {};
  const validEntries = Object.entries(obj).filter(([key]) => keys.includes(key));
  return Object.fromEntries(validEntries);
}

// src/files/config.ts
function getBooleanFromEnv(value, command) {
  return value === "dev" ? command === "serve" : value === "prod" ? command === "build" : value != null ? value : false;
}
function resolveBackend(options, command) {
  const _a = options, { local, name } = _a, backend = __objRest(_a, ["local", "name"]);
  const git = getGitData();
  const branch = "useCurrentBranch" in options && getBooleanFromEnv(options.useCurrentBranch, command) ? git.getBranch() : "branch" in backend ? backend.branch : void 0;
  delete backend.useCurrentBranch;
  const resolved = {
    local_backend: typeof local === "object" ? objToSnakeCase(local) : getBooleanFromEnv(local, command),
    backend: __spreadProps(__spreadValues({}, objToSnakeCase(backend)), {
      branch,
      name
    })
  };
  return resolved;
}
function createConfigFile(config, command, log) {
  const _a = config, { backend, collections } = _a, options = __objRest(_a, ["backend", "collections"]);
  return __spreadProps(__spreadValues(__spreadValues({}, resolveBackend(backend, command)), objToSnakeCase(options)), {
    collections: collections.map((col) => {
      if ("fields" in col) {
        const _a2 = col, { fields } = _a2, data = __objRest(_a2, ["fields"]);
        return __spreadProps(__spreadValues({}, objToSnakeCase(data)), {
          fields: fields.map(objToSnakeCase)
        });
      } else if ("files" in col) {
        const _b = col, { files } = _b, data = __objRest(_b, ["files"]);
        return __spreadProps(__spreadValues({}, objToSnakeCase(data)), {
          files: files.map((file) => {
            const _a3 = file, { fields } = _a3, _data = __objRest(_a3, ["fields"]);
            return __spreadProps(__spreadValues({}, objToSnakeCase(_data)), {
              fields: fields.map(objToSnakeCase)
            });
          })
        });
      } else log("config", "stderr", "Missing either fields or files property in collection");
    })
  });
}

// src/script.ts
function createCmsFunction(method, items, createParams, options) {
  var _a;
  const create = (params) => {
    var _a2;
    return `${(_a2 = options == null ? void 0 : options.base) != null ? _a2 : "CMS"}.${method}(${params})`;
  };
  return (items != null ? items : []).map((item) => {
    const params = createParams(item);
    if (!params) return null;
    else return create(params);
  }).filter(Boolean).join((_a = options == null ? void 0 : options.joinChar) != null ? _a : "\n");
}
function createScript(options) {
  const _a = options, {
    useManualInitialization,
    markdownEditorComponents,
    formatters,
    previewStylesheets,
    onGenerated: onGenerated,
    onInitialized
  } = _a, eventHooks = __objRest(_a, [
    "useManualInitialization",
    "markdownEditorComponents",
    "formatters",
    "previewStylesheets",
    // previewTemplates,
    // widgets,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    "onGenerated",
    "onInitialized"
  ]);
  const events = createCmsFunction("registerEventListener", Object.keys(eventHooks), (hookName) => {
    const hook = eventHooks[hookName];
    if (!hook) return null;
    else {
      const name = hookName.slice(2)[0].toLowerCase() + hookName.slice(3);
      return `{ name: '${name}', handler: data => { function ${hook.toString()}; ${hookName}({ app: CMS, ...data }) } }`;
    }
  });
  const customFormatters = createCmsFunction("registerCustomFormat", formatters, ({ name, extension, formatter }) => {
    return `'${name}', '${extension}', ${formatter.toString()}`;
  });
  const customStyles = createCmsFunction("registerPreviewStyle", previewStylesheets, (style) => {
    return typeof style === "string" ? style : `${style.style}, { raw: ${style.options.raw} }`;
  });
  const editorComponents = createCmsFunction("registerEditorComponent", markdownEditorComponents, (item) => {
    const _a2 = item, { pattern, toPreview, toBlock, fromBlock } = _a2, component = __objRest(_a2, ["pattern", "toPreview", "toBlock", "fromBlock"]);
    return `{ pattern: ${pattern}, toPreview: ${toPreview.toString()}, toBlock: ${toBlock.toString()}, fromBlock: ${fromBlock.toString()}, ...${JSON.stringify(component)}}`;
  });
  return `
<script>
${useManualInitialization ? "window.CMS_MANUAL_INIT = true;" : ""}
${onInitialized != void 0 ? `window.onload = () => { function ${onInitialized.toString()}; onInitialized({ app: CMS }) }` : ""}
${customFormatters}
${customStyles}
${events}
${editorComponents}
</script>`;
}

// src/files/index.ts
var defaultDecapCmsCdnVersion = "3.1.11";
var defaultNetlifyIdentityVersion = "1";
var addSlash = (path, slash = "/") => path.endsWith(slash) ? path : path + slash;
function resolveCdnRoute(options) {
  const getUrl = (host = "https://unpkg.com/", version = defaultDecapCmsCdnVersion) => {
    return `${addSlash(host)}decap-cms@^${version}/dist/decap-cms.js`;
  };
  return typeof options === "boolean" ? options ? getUrl() : void 0 : typeof options === "string" ? options : options != void 0 ? getUrl(options.base, options.version) : void 0;
}
function resolveHead(head) {
  return head.reduce((output, config) => {
    if (typeof config === "string") return output.concat(config);
    if ("skip" in config) {
      if (config.skip) return output;
      if (typeof config.head === "string") return output.concat(config.head);
    }
    const item = "head" in config ? config.head : config;
    let str = `<${item[0]}`;
    for (const key in item[1]) {
      str += ` ${key}="${item[1][key]}"`;
    }
    str += item[0] === "meta" ? "/>" : ">";
    if (item[2] == void 0) return output.concat(str);
    str += item[2] + `</${item[0]}>`;
    return output.concat(str);
  }, []);
}
function getIndexFeatures(config, loadOptions) {
  var _a;
  const configRoute = config.dir ? addSlash(config.dir) + "config.yml" : void 0;
  return {
    cdn_route: resolveCdnRoute(loadOptions == void 0 || loadOptions.method === "cdn" ? (_a = loadOptions == null ? void 0 : loadOptions.options) != null ? _a : true : void 0),
    custom_logo: "logoUrl" in config ? config.logoUrl != void 0 : "logo_url" in config ? config.logo_url != void 0 : false,
    head: (options) => {
      var _a2, _b, _c;
      return resolveHead([
        ["meta", { charset: "utf-8" }],
        ["meta", { name: "viewport", content: "width=device-width, initial-scale=1.0" }],
        ["meta", { name: "robots", content: "noindex" }],
        ...(_a2 = options == null ? void 0 : options.head) != null ? _a2 : [],
        ["title", {}, (_b = options == null ? void 0 : options.title) != null ? _b : "Content Manager"],
        {
          head: ["link", { rel: "favicon", ref: (_c = options == null ? void 0 : options.icon) != null ? _c : "" }],
          skip: (options == null ? void 0 : options.icon) == void 0
        },
        {
          head: ["script", { src: `https://identity.netlify.com/v${defaultNetlifyIdentityVersion}/netlify-identity-widget.js` }],
          skip: config.backend.name !== "git-gateway"
        },
        {
          head: ["link", { type: "text/yaml", rel: "cms-config-url", href: configRoute }],
          skip: configRoute == void 0
        }
      ]);
    }
  };
}
function createIndexFile(pluginOptions) {
  var _a, _b;
  const { config, load, login: options, script } = pluginOptions;
  if (options == null ? void 0 : options.html) return options.html;
  const features = getIndexFeatures(config, load);
  return `<!DOCTYPE html>
<html>
    <head>
        ${features.head(options).join("\n" + " ".repeat(8))}
    </head>
    <body>
        ${features.cdn_route ? `<script src="${features.cdn_route}"></script>` : ""}
        ${script ? createScript(script) : ""}
        ${((_a = pluginOptions.login) == null ? void 0 : _a.additionalHtml) ? `${(_b = pluginOptions.login) == null ? void 0 : _b.additionalHtml}

<div id="nc-root"></div>` : ""}
    </body>
</html>${features.custom_logo ? `

<style>
span[class*='CustomIconWrapper'] {
    width: auto;
}
</style>` : ""}`;
}

// src/proxy.ts
var import_node_child_process2 = require("child_process");
function runProxy(options, log) {
  var _a, _b, _c, _d, _e;
  const port = ((_a = options == null ? void 0 : options.port) != null ? _a : 8081).toString();
  log("proxy", "debug", `Starting decap-server on port ${port}`);
  const proxy = (0, import_node_child_process2.exec)("npx decap-server", __spreadProps(__spreadValues({}, (_b = options == null ? void 0 : options.process) != null ? _b : {}), {
    env: __spreadValues({
      PORT: port,
      MODE: options == null ? void 0 : options.mode,
      LOG_LEVEL: options == null ? void 0 : options.logLevel,
      GIT_REPO_DIRECTORY: options == null ? void 0 : options.gitRepoDirectory
    }, (_d = (_c = options == null ? void 0 : options.process) == null ? void 0 : _c.env) != null ? _d : {})
  }));
  if (log("proxy", "stdout")) (_e = proxy.stdout) == null ? void 0 : _e.pipe(process.stdout);
  proxy.on("error", (err) => {
    if ("code" in err && err.code === "EADDRINUSE") {
      log("proxy", "stderr", `Port ${port} for decap-server is already used by another process`);
    } else throw err;
  });
  process.on("beforeExit", () => proxy.kill());
}

// src/update.ts
function resolveDir(publicDir, dir) {
  return dir ? (0, import_node_path.isAbsolute)(dir) ? dir : (0, import_node_path.resolve)(dir) : publicDir;
}
async function writeToFolder(folder, options) {
  const dir = folder + (options.subfolder ? import_node_path.sep + options.subfolder : "");
  await (0, import_promises.mkdir)(dir, { recursive: true });
  for (const file of options.files.filter((f) => !f.skip)) {
    await (0, import_promises.writeFile)(dir + import_node_path.sep + file.name, file.content, {
      encoding: "utf-8"
    });
  }
}
function validateLoadOptions(options, log) {
  var _a;
  const valid = ["npm", "cdn"].includes((_a = options == null ? void 0 : options.method) != null ? _a : "cdn");
  if (!valid) log("config", "stderr", "Invalid load options for decap-cms provided");
}
async function updateConfig(options, config, log) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  validateLoadOptions(options.load, log);
  const configFile = createConfigFile(options.config, config.command, log);
  await writeToFolder(
    resolveDir(config.publicDir, options.dir),
    {
      subfolder: "admin",
      files: [
        { name: "index.html", content: createIndexFile(options) },
        { name: "config.yml", content: (0, import_yaml.stringify)(configFile, (_a = options.yml) == null ? void 0 : _a.replacer, (_b = options.yml) == null ? void 0 : _b.options) }
        // { name: 'npm.js', content: createCustomScript(), skip: options.load?.method !== 'npm' },
      ]
    }
  );
  if (config.command === "serve" && configFile.local_backend !== false && ((_d = (_c = options.proxy) == null ? void 0 : _c.enabled) != null ? _d : true)) {
    runProxy(options.proxy, log);
  }
  await ((_f = (_e = options.script) == null ? void 0 : _e.onConfigUpdated) == null ? void 0 : _f.call(_e));
  if (config.command === "build") {
    await ((_h = (_g = options.script) == null ? void 0 : _g.onGenerated) == null ? void 0 : _h.call(_g));
  }
}

// src/utils/log.ts
function createLogger(options) {
  return function(type, pipe, ...data) {
    if (options == void 0 || options === false) {
      if (!data.length) return false;
      else return;
    }
    if (!data.length) return true;
    const fn = pipe === "stderr" ? "error" : pipe === "debug" ? "debug" : "log";
    const pipeDefined = ["debug", "stdout", "stderr"].includes(pipe);
    for (const msg of pipeDefined ? data : [pipe, ...data]) {
      console[fn](`[Vite Decap] - [${type.toUpperCase()}] ` + msg);
    }
  };
}

// src/utils/collection.ts
function createField(widget, data) {
  return __spreadProps(__spreadValues({}, data), {
    widget
  });
}
function createFolderCollection(data) {
  return data;
}
function createFile(data) {
  return data;
}
function createFileCollection(data) {
  return data;
}
function fieldToSnakeCase(field) {
  return objToSnakeCase(field);
}
function createSharedCollectionOptions(shared, options) {
  return function(collection) {
    const isSharedOptions = (value) => {
      return value != void 0 && typeof value === "object" && "value" in value && !("field" in value);
    };
    const combinedWithShared = keyof(collection).reduce((output, key) => {
      var _a, _b;
      const collectionValue = collection[key];
      const sharedValue = shared[key];
      if (sharedValue != void 0) {
        if (isSharedOptions(sharedValue)) {
          const sharedOptions = sharedValue;
          const action = (_b = (_a = sharedOptions.action) != null ? _a : options == null ? void 0 : options.action) != null ? _b : "overwrite";
          if (action === "overwrite") {
            output[key] = collectionValue;
            return output;
          } else if (action === "append") {
            if (typeof collectionValue === "string") {
              output[key] = sharedOptions.value + collectionValue;
            } else if (Array.isArray(collectionValue)) {
              output[key] = sharedOptions.value.concat(collectionValue);
            }
            return output;
          }
        }
      }
      output[key] = collectionValue;
      return output;
    }, {});
    const sharedRaw = keyof(shared).reduce((output, key) => {
      const value = shared[key];
      if (isSharedOptions(value)) {
        output[key] = value.value;
      } else {
        output[key] = value;
      }
      return output;
    }, {});
    return __spreadValues(__spreadValues({}, sharedRaw), combinedWithShared);
  };
}

// src/utils/overwrites.ts
function createOverwriteableField(widget, data, overwrites) {
  if (overwrites != void 0) {
    const toAdd = (key) => {
      if ((overwrites == null ? void 0 : overwrites[key]) != void 0 && data[key] !== overwrites[key]) data[key] = overwrites[key];
    };
    for (const key of Object.keys(overwrites)) {
      if (key !== "hidden" && key !== "deleted") {
        toAdd(key);
      }
    }
  }
  if (overwrites == null ? void 0 : overwrites.deleted) return void 0;
  else if ((overwrites == null ? void 0 : overwrites.hidden) && widget !== "hidden") return createField("hidden", data);
  else return __spreadProps(__spreadValues({}, data), {
    widget
  });
}

// src/vitepress.ts
var overwriteKeys = [
  "comment",
  "deleted",
  "hidden",
  "hint",
  "label",
  "media_folder",
  "i18n",
  "pattern",
  "public_folder",
  "required"
];
function mergeOverwrites(main, parent) {
  var _a;
  if (parent == void 0) return main != null ? main : {};
  else if (main == void 0) return (_a = pick(parent != null ? parent : {}, overwriteKeys)) != null ? _a : {};
  else {
    return overwriteKeys.reduce((combined, key) => {
      if ((main == null ? void 0 : main[key]) != void 0) combined[key] = main[key];
      else if ((parent == null ? void 0 : parent[key]) != void 0) combined[key] = parent[key];
      return combined;
    }, {});
  }
}
var VitePress = class {
  /**
   * Create fields for:
   * - layout
   * - navbar
   * - sidebar
   * - aside
   * - outline
   * - lastUpdated
   * - editLink
   * - footer
   * - pageClass
   * 
   * Does not create the default page fields, such as title and description. 
   * @param options Options for overwriting field data
   * @see https://vitepress.dev/reference/frontmatter-config#default-theme-only
   */
  static createDefaultThemeNormalPageFields(options) {
    const { overwrites } = options != null ? options : {};
    return [
      createOverwriteableField("string", {
        name: "layout",
        label: "Layout",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.layout, overwrites)),
      createOverwriteableField("boolean", {
        name: "navbar",
        label: "Whether to display the navbar",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.navbar, overwrites)),
      createOverwriteableField("boolean", {
        name: "sidebar",
        label: "Whether to display the sidebar",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.sidebar, overwrites)),
      // TODO: add aside 'left' option
      createOverwriteableField("boolean", {
        name: "aside",
        label: "Whether to display the aside container",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.aside, overwrites)),
      // TODO: add support for [number, number] | 'deep' | false
      createOverwriteableField("number", {
        name: "outline",
        label: "The header levels in the outline",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.outline, overwrites)),
      // TODO: add support for Date 
      createOverwriteableField("boolean", {
        name: "lastUpdated",
        label: "Whether to display last updated text",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.lastUpdated, overwrites)),
      createOverwriteableField("boolean", {
        name: "editLink",
        label: "Whether to display edit link text",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.editLink, overwrites)),
      createOverwriteableField("boolean", {
        name: "footer",
        label: "Whether to display footer text",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.footer, overwrites)),
      createOverwriteableField("string", {
        name: "pageClass",
        label: "Page class",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.pageClass, overwrites))
    ].filter(filterUndefined);
  }
  /**
   * Create fields for:
   * - title
   * - titleTemplate
   * - description
   * - head
   * - body (field for writing the markdown in the file)
   * @param options.overwrites Overwrite data, such as labels, for the fields
   * @see https://vitepress.dev/reference/frontmatter-config
   */
  static createDefaultPageFields(options) {
    var _a, _b, _c;
    const { additionalFields, overwrites } = options != null ? options : {};
    const fields = [
      createOverwriteableField("string", {
        name: "title",
        label: "Title"
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.title, overwrites)),
      createOverwriteableField("string", {
        name: "titleTemplate",
        label: "Title template",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.titleTemplate, overwrites)),
      createOverwriteableField("text", {
        name: "description",
        label: "Description",
        required: false
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.description, overwrites)),
      createOverwriteableField("list", {
        name: "head",
        label: "Head"
      }, mergeOverwrites(overwrites == null ? void 0 : overwrites.head, overwrites))
    ].filter(filterUndefined);
    return fields.concat((_a = additionalFields == null ? void 0 : additionalFields.map(fieldToSnakeCase)) != null ? _a : []).concat((_c = createOverwriteableField("markdown", __spreadProps(__spreadValues({}, (_b = options == null ? void 0 : options.markdownOptions) != null ? _b : {}), {
      name: "body",
      label: "Page content"
    }), mergeOverwrites(overwrites == null ? void 0 : overwrites.body, overwrites))) != null ? _c : []).filter(filterUndefined);
  }
  /**
   * Create fields for:
   * - layout: home (not overwriteable)
   * - hero
   * - features
   * 
   * The object fields (`features`, `hero`, `heroActions`) can not be hidden and deleted.
   */
  static createHomePageFields(options) {
    var _a;
    const { overwrites } = options != null ? options : {};
    const keys = ["hidden", "deleted"];
    function addAdditionalFields(fields) {
      var _a2;
      return (_a2 = fields == null ? void 0 : fields.map(fieldToSnakeCase)) != null ? _a2 : [];
    }
    return [
      createField("hidden", {
        name: "layout",
        default: "home"
      }),
      createOverwriteableField("object", {
        name: "hero",
        label: "Hero items",
        required: true,
        fields: [
          createOverwriteableField("string", {
            name: "name",
            required: false
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.heroName, overwrites)),
          createOverwriteableField("string", {
            name: "text"
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.heroText, overwrites)),
          createOverwriteableField("string", {
            name: "tagline",
            required: false
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.heroTagline, overwrites)),
          // TODO: add support for object options
          createOverwriteableField("image", {
            name: "image",
            required: false
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.heroImage, overwrites)),
          createOverwriteableField("list", {
            name: "actions",
            label: "Action buttons",
            label_singular: "action",
            allow_add: true,
            fields: [
              createOverwriteableField("string", {
                name: "text"
              }, mergeOverwrites(overwrites == null ? void 0 : overwrites.heroActionText, overwrites)),
              createOverwriteableField("string", {
                name: "link"
              }, mergeOverwrites(overwrites == null ? void 0 : overwrites.heroActionLink, overwrites)),
              createOverwriteableField("select", {
                name: "theme",
                required: false,
                default: "brand",
                options: [
                  "brand",
                  "alt"
                ]
              }, mergeOverwrites(overwrites == null ? void 0 : overwrites.heroActionTheme, overwrites)),
              createOverwriteableField("string", {
                name: "target",
                required: false
              }, mergeOverwrites(overwrites == null ? void 0 : overwrites.heroActionTarget, overwrites)),
              createOverwriteableField("string", {
                name: "rel",
                required: false
              }, mergeOverwrites(overwrites == null ? void 0 : overwrites.heroActionRel, overwrites)),
              ...addAdditionalFields(options == null ? void 0 : options.additionalHeroActionFields)
            ].filter(filterUndefined)
          }, omit(mergeOverwrites(overwrites == null ? void 0 : overwrites.heroActions, overwrites), keys)),
          ...addAdditionalFields(options == null ? void 0 : options.additionalHeroFields)
        ].filter(filterUndefined)
      }, omit(mergeOverwrites(overwrites == null ? void 0 : overwrites.hero, overwrites), keys)),
      createOverwriteableField("list", {
        name: "features",
        label: "Features",
        label_singular: "feature",
        allow_add: true,
        required: false,
        fields: [
          createOverwriteableField("string", {
            name: "title",
            required: true
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.featuresTitle, overwrites)),
          createOverwriteableField("string", {
            name: "details",
            required: false
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.featuresDetails, overwrites)),
          // TODO: add support for object options
          createOverwriteableField("string", {
            name: "icon",
            required: false
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.featuresIcon, overwrites)),
          createOverwriteableField("string", {
            name: "link",
            required: false
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.featuresLink, overwrites)),
          createOverwriteableField("string", {
            name: "linkText",
            label: "Link text",
            required: false
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.featuresLinkText, overwrites)),
          createOverwriteableField("string", {
            name: "target",
            label: "Target",
            required: false
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.featuresTarget, overwrites)),
          createOverwriteableField("string", {
            name: "rel",
            required: false
          }, mergeOverwrites(overwrites == null ? void 0 : overwrites.featuresRel, overwrites)),
          ...addAdditionalFields((_a = options == null ? void 0 : options.additionalFeatureFields) != null ? _a : [])
        ].filter(filterUndefined)
      }, omit(mergeOverwrites(overwrites == null ? void 0 : overwrites.features, overwrites), keys))
    ].filter(filterUndefined);
  }
  static createDefaultPageFolderCollection(name, folder, options) {
    const _a = options != null ? options : {}, { collection } = _a, fieldsOptions = __objRest(_a, ["collection"]);
    const fields = this.createDefaultPageFields(fieldsOptions);
    return createFolderCollection(__spreadProps(__spreadValues({
      name,
      label: name,
      folder
    }, collection != null ? collection : {}), {
      fields
    }));
  }
  static createDefaultPageFile(name, file, options) {
    const _a = options != null ? options : {}, { collection } = _a, fieldsOptions = __objRest(_a, ["collection"]);
    const fields = this.createDefaultPageFields(fieldsOptions);
    return createFile(__spreadProps(__spreadValues({
      name,
      file,
      label: name
    }, collection != null ? collection : {}), {
      fields
    }));
  }
  static createDefaultPageFileCollection(name, files, options) {
    var _a;
    return createFileCollection(__spreadProps(__spreadValues({
      name,
      label: name
    }, (_a = options == null ? void 0 : options.collection) != null ? _a : {}), {
      files: files.map((params) => this.createDefaultPageFile(...params))
    }));
  }
};

// src/index.ts
function VitePluginDecapCMS(options) {
  let stored = null;
  return {
    name: "vite-plugin-decap-cms",
    async configResolved(config) {
      const needsUpdate = stored != null ? stored.command !== config.command || stored.publicDir !== config.publicDir : true;
      const log = createLogger(options.debug);
      if (needsUpdate) {
        await updateConfig(options, config, log);
        stored = config;
        log("config", "debug", "Updated Decap CMS configuration files");
      } else {
        log("config", "debug", "Skipped updating Decap CMS configuration files");
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VitePress,
  createField,
  createFile,
  createFileCollection,
  createFolderCollection,
  createOverwriteableField,
  createSharedCollectionOptions,
  fieldToSnakeCase,
  getGitData
});
